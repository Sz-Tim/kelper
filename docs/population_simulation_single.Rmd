---
title: "KELPER"
subtitle: "Population simulation"
author: "Tim Szewczyk"
output:
  html_document:
    theme: spacelab
    df_print: paged
    anchor_sections: TRUE
    toc: yes
    toc_depth: 2
    toc_float: true
  pdf_document:
    toc: yes
  html_notebook:
    theme: spacelab
    toc: yes
editor_options: 
  chunk_output_type: console
---

# Overview

This script simulates an individual population using data from the literature.


```{r setup, echo=F, include=F}
# set directory for knitr as main project directory
knitr::opts_knit$set(root.dir=rprojroot::find_rstudio_root_file())
```

```{r workspace, echo=F, include=F, message=F, warning=F}
pkgs <- c("raster", "lubridate", "tidyverse", "sf", "brms")
suppressMessages(invisible(lapply(pkgs, library, character.only=T)))
walk(dir("code", "^00.*R", full.names=T), source)
theme_set(theme_bw()); options(mc.cores=4)

gis.dir <- "..\\..\\00_gis\\"
UK_bbox <- st_bbox(c(xmin=-11, xmax=2, ymin=49, ymax=61), crs=st_crs(4326))
data.dir <- "..\\data\\digitized\\"
supp.f <- "data\\raw\\collab\\collab_all.xlsx"
data.ls <- compileDatasets(data.dir, supp.f)

site.i <- read_csv(paste0(data.dir, "sitesDigitized.csv"),
                   col_select=1:3, show_col_types=F)

rerun_modelFits <- T
lmType <- c("lm", "brms")[1]
PAR_datasource <- c("MODIS", "POWER")[1]
```



```{r covariates}
covars.ls <- list(
  fetch=dir(paste0(gis.dir, "dataGeog"), "^FetchUK_200m", full.names=T) %>% 
    read_csv(show_col_types=F) %>% st_as_sf(coords=c("OSEast", "OSNorth")) %>% 
    st_set_crs(27700) %>% st_transform(4326),
  sst_day=dir(paste0(gis.dir, "dataEnv\\climate"), 
              "MODISA_L3m_SST_Monthly", full.names=T) %>%
    raster() %>% crop(UK_bbox),
  sst_night=dir(paste0(gis.dir, "dataEnv\\climate"), 
                "MODISA_L3m_NSST_Monthly", full.names=T) %>%
    raster() %>% crop(UK_bbox),
  chla=dir(paste0(gis.dir, "dataEnv\\chla"), 
           "MODISA_L3m_CHL", full.names=T) %>%
    raster() %>% crop(UK_bbox),
  KD_mn=dir(paste0(gis.dir, "dataEnv\\attenuation"), 
                 "MODISA_L3m_KD.*11W_49N", full.names=T) %>%
    map(raster) %>% stack %>% crop(UK_bbox) %>% calc(mean, na.rm=T),
  KD_sd=dir(paste0(gis.dir, "dataEnv\\attenuation"), 
                 "MODISA_L3m_KD.*11W_49N", full.names=T) %>%
    map(raster) %>% stack %>% crop(UK_bbox) %>% calc(sd, na.rm=T),
  PAR_mn=dir(paste0(gis.dir, "dataEnv\\light"), 
                 "MODISA_L3m_PAR", full.names=T) %>%
    map(raster) %>% stack %>% crop(UK_bbox) %>% calc(mean, na.rm=T),
  PAR_sd=dir(paste0(gis.dir, "dataEnv\\light"), 
                 "MODISA_L3m_PAR", full.names=T) %>%
    map(raster) %>% stack %>% crop(UK_bbox) %>% calc(sd, na.rm=T),
  irrad_longterm=dir(paste0(gis.dir, "dataEnv\\light"), 
                     "POWER_Regional_Climatology", full.names=T) %>%
    read_csv(skip=10, show_col_types=F) %>% 
    st_as_sf(coords=c("LON", "LAT"), crs=4326),
  irrad_monthly=dir(paste0(gis.dir, "dataEnv\\light"), 
                     "POWER_Regional_monthly", full.names=T) %>%
    read_csv(skip=10, show_col_types=F) %>% 
    filter(JAN != -999) %>% select(-ANN) %>%
    group_by(PARAMETER, YEAR) %>% mutate(id=row_number()) %>% ungroup %>%
    pivot_longer(5:16, names_to="MONTH", values_to="PAR") %>%
    st_as_sf(coords=c("LON", "LAT"), crs=4326),
  irrad_daily=dir(paste0(gis.dir, "dataEnv\\light"), 
                     "POWER_Regional_Daily", full.names=T) %>%
    map_dfr(., ~read_csv(.x, skip=10, show_col_types=F)) %>% 
    mutate(DATE=case_when(is.na(DOY) ~ ymd(paste(YEAR, MO, DY, sep="-")),
                          !is.na(DOY) ~ as_date(DOY, 
                                                origin=paste0(YEAR,"-01-01")))) %>% 
    group_by(DATE) %>% mutate(id=row_number()) %>% ungroup %>%
    pivot_longer(contains("_PAR_"), names_to="PARAMETER", values_to="PAR") %>%
    st_as_sf(coords=c("LON", "LAT"), crs=4326)
)

irrad.grid <- (st_bbox(covars.ls$irrad_longterm) + .25*c(-1,-1,1,1)) %>%
  st_make_grid(cellsize=c(0.5, 0.5)) %>% st_sf(id=1:length(.))

covars.ls$irrad_growing.month <- covars.ls$irrad_monthly %>%
  filter(MONTH %in% c("JAN", "FEB", "MAR", "APR", "MAY", "JUN")) %>%
  group_by(PARAMETER, YEAR, id) %>%
  summarise(PAR=mean(PAR)) %>%
  group_by(PARAMETER, id) %>%
  summarise(mnPAR=mean(PAR), sdPAR=sd(PAR)) %>%
  st_join(irrad.grid, .) %>%
  filter(grepl("ALLSKY", PARAMETER))

for(i in seq_along(data.ls)) {
  if(any(!is.na(data.ls[[i]]$lat))) {
    i_sf <- data.ls[[i]] %>% 
      filter(!is.na(lat) & !is.na(lon)) %>%
      st_as_sf(coords=c("lon", "lat"), crs=4326) %>%
      mutate(sst_day=raster::extract(covars.ls$sst_day, ., 
                                     fun=mean, small=T, method="bilinear"),
             sst_night=raster::extract(covars.ls$sst_night, ., 
                                       fun=mean, small=T, method="bilinear"),
             chla=raster::extract(covars.ls$chla, ., 
                                  fun=mean, small=T, method="bilinear"),
             KD_mn=raster::extract(covars.ls$KD_mn, ., 
                                   fun=mean, small=T, method="bilinear"),
             KD_sd=raster::extract(covars.ls$KD_sd, ., 
                                   fun=mean, small=T, method="bilinear"),
             PAR_mn=raster::extract(covars.ls$PAR_mn, ., 
                                    fun=mean, small=T, method="bilinear"),
             PAR_sd=raster::extract(covars.ls$PAR_sd, ., 
                                    fun=mean, small=T, method="bilinear"),
             PAR_POWER=st_join(., 
                                 covars.ls$irrad_growing.month, 
                                 left=T, join=st_nearest_feature)$mnPAR)
    data.ls[[i]] <- left_join(data.ls[[i]], st_drop_geometry(i_sf))
    if(any(!is.na(data.ls[[i]]$depth))) {
      data.ls[[i]] <- data.ls[[i]] %>%
        mutate(PAR_atDepth_POWER=PAR_POWER * exp(-KD_mn * depth),
               PAR_atDepth_MODIS=PAR_mn * exp(-KD_mn * depth))
      data.ls[[i]]$PAR_atDepth <- data.ls[[i]][[paste0("PAR_atDepth_", PAR_datasource)]]
    }
  }
}

fetch_thirds <- quantile(covars.ls$fetch$fetchsum, probs=(1:2)/3)
site.sf <- site.i %>% 
  filter(!is.na(lat) & !is.na(lon)) %>%
  st_as_sf(coords=c("lon", "lat"), crs=4326) %>%
  mutate(sst_day=raster::extract(covars.ls$sst_day, ., 
                                 fun=mean, small=T, method="bilinear"),
         sst_night=raster::extract(covars.ls$sst_night, ., 
                                   fun=mean, small=T, method="bilinear"),
         chla=raster::extract(covars.ls$chla, ., 
                              fun=mean, small=T, method="bilinear"),
         KD_mn=raster::extract(covars.ls$KD_mn, ., 
                               fun=mean, small=T, method="bilinear"),
         KD_sd=raster::extract(covars.ls$KD_sd, ., 
                               fun=mean, small=T, method="bilinear"),
         PAR_mn=raster::extract(covars.ls$PAR_mn, ., 
                                fun=mean, small=T, method="bilinear"),
         PAR_sd=raster::extract(covars.ls$PAR_sd, ., 
                                fun=mean, small=T, method="bilinear"),
         PAR_POWER=st_join(., 
                           covars.ls$irrad_growing.month, 
                           left=T, join=st_nearest_feature)$mnPAR,
         fetch=st_join(., 
                       covars.ls$fetch, 
                       left=T, join=st_nearest_feature)$fetchsum,
         fetchCat=case_when(fetch < fetch_thirds[1] ~ 1,
                            between(fetch, fetch_thirds[1], fetch_thirds[2]) ~ 2,
                            fetch > fetch_thirds[2] ~ 3))
site.sf$PAR_surface <- site.sf[[ifelse(PAR_datasource=="MODIS", "PAR_mn", "PAR_POWER")]]
```




# Extract relevant data

## Allometry 

Allometric relationships include stipe length : stipe weight, stipe weight : frond weight, and frond weight : frond area. All are linear on a log-log scale. Plants invest more in fronds relative to stipes when the canopy is thinner, and fronds are thinner at greater depths. Both are suggestive of responses to light availability and limitation. 

```{r extract_allometry}
if(rerun_modelFits) {
  # Stipe length (mm) -> stipe weight (g) : global
  if(lmType=="brms") {
    lenStipe_wtStipe <- data.ls$lengthStipe_weightStipe %>%
      mutate(logWtStipe=log(weightStipe), 
             logLenStipe=log(lengthStipe)) %>%
      brm(logWtStipe ~ logLenStipe, prior=prior(normal(0,5)),  data=.)
    saveRDS(lenStipe_wtStipe, "temp/brms_lenStipe_wtStipe.rds")
  } else {
    lenStipe_wtStipe <- data.ls$lengthStipe_weightStipe %>%
      mutate(logWtStipe=log(weightStipe), 
             logLenStipe=log(lengthStipe)) %>%
      lm(logWtStipe ~ logLenStipe,  data=.)
    saveRDS(lenStipe_wtStipe, "temp/lm_lenStipe_wtStipe.rds")
  }
  
  # Stipe weight (g) -> frond weight (g) : kappa-dependent
  if(lmType=="brms") {
    wtStipe_wtFrond.kappa <- data.ls$weightStipe_weightFrond %>% 
      mutate(propClear=as.numeric(habitat=="clearing"),
             logWtFrond=log(weightFrond), 
             logWtStipe=log(weightStipe)) %>%
      brm(logWtFrond ~ logWtStipe*propClear, prior=prior(normal(0,5)), data=.)
    saveRDS(wtStipe_wtFrond.kappa, "temp/brms_wtStipe_wtFrond_kappa.rds")
  } else {
    wtStipe_wtFrond.kappa <- data.ls$weightStipe_weightFrond %>% 
      mutate(propClear=as.numeric(habitat=="clearing"),
             logWtFrond=log(weightFrond), 
             logWtStipe=log(weightStipe)) %>%
      lm(logWtFrond ~ logWtStipe*propClear, data=.)
    saveRDS(wtStipe_wtFrond.kappa, "temp/lm_wtStipe_wtFrond_kappa.rds")
  }
  
  # Frond weight (g) -> frond area (cm2 -> m2) : depth-dependent
  if(lmType=="brms") {
    wtFrond_areaFrond.PAR_atDepth <- data.ls$weightFrond_areaFrond %>%
      mutate(logWtFrond=log(weightFrond),
             logAreaFrond=log(areaFrond/1e4)) %>%
      brm(logAreaFrond ~ logWtFrond*PAR_atDepth, prior=prior(normal(0,5)), data=.)
    saveRDS(wtFrond_areaFrond.PAR_atDepth, "temp/brms_wtFrond_areaFrond_PARdepth.rds") 
  } else {
    wtFrond_areaFrond.PAR_atDepth <- data.ls$weightFrond_areaFrond %>%
      mutate(logWtFrond=log(weightFrond),
             logAreaFrond=log(areaFrond/1e4)) %>%
      lm(logAreaFrond ~ logWtFrond*PAR_atDepth, data=.)
    saveRDS(wtFrond_areaFrond.PAR_atDepth, "temp/lm_wtFrond_areaFrond_PARdepth.rds") 
  }
  
  # Frond area (cm2 -> m2) -> frond weight (g) : depth-dependent
  if(lmType=="brms") {
    areaFrond_wtFrond.PAR_atDepth <- data.ls$weightFrond_areaFrond %>%
      mutate(logWtFrond=log(weightFrond),
             logAreaFrond=log(areaFrond/1e4)) %>%
      brm(logWtFrond ~ logAreaFrond*PAR_atDepth, prior=prior(normal(0,5)), data=.)
    saveRDS(areaFrond_wtFrond.PAR_atDepth, "temp/brms_areaFrond_wtFrond_PARdepth.rds")
  } else {
    areaFrond_wtFrond.PAR_atDepth <- data.ls$weightFrond_areaFrond %>%
      mutate(logWtFrond=log(weightFrond),
             logAreaFrond=log(areaFrond/1e4)) %>%
      lm(logWtFrond ~ logAreaFrond*PAR_atDepth, data=.)
    saveRDS(areaFrond_wtFrond.PAR_atDepth, "temp/lm_areaFrond_wtFrond_PARdepth.rds")
  }

  
} else {
  lenStipe_wtStipe <- readRDS(paste0("temp\\", lmType, "_lenStipe_wtStipe.rds"))
  wtStipe_wtFrond.kappa <- readRDS(paste0("temp\\", lmType, "_wtStipe_wtFrond_kappa.rds"))
  wtFrond_areaFrond.PAR_atDepth <- readRDS(paste0("temp\\", lmType, "_wtFrond_areaFrond_PARdepth.rds"))
  areaFrond_wtFrond.PAR_atDepth <- readRDS(paste0("temp\\", lmType, "_areaFrond_wtFrond_PARdepth.rds"))
}

# Plots
if(lmType=="brms") {
  p1 <- conditional_effects(lenStipe_wtStipe)
  plot(p1, plot=F)[[1]] + ggtitle("Stipe weight ~ Stipe length")
  p2 <- conditional_effects(wtStipe_wtFrond.kappa, effects="logWtStipe:propClear",
                            int_conditions=list(propClear=seq(0,1,0.2)))
  plot(p2, plot=F)[[1]] + scale_colour_viridis_d(option="E") +
    scale_fill_viridis_d(option="E") + ggtitle("Frond weight ~ Stipe weight")
  p3 <- conditional_effects(wtFrond_areaFrond.PAR_atDepth, effects="logWtFrond:PAR_atDepth",
                            int_conditions=list(PAR_atDepth=seq(0,20,5)))
  plot(p3, plot=F)[[1]] + scale_colour_viridis_d() +
    scale_fill_viridis_d() + ggtitle("Frond area ~ Frond weight")
  p4 <- conditional_effects(areaFrond_wtFrond.PAR_atDepth, effects="logAreaFrond:PAR_atDepth",
                            int_conditions=list(PAR_atDepth=seq(0,20,5)))
  plot(p4, plot=F)[[1]] + scale_colour_viridis_d() +
    scale_fill_viridis_d() + ggtitle("Frond weight ~ Frond area") 
}
```


## Growth

Stipe growth over the course of the year is decently approximated by a harmonic model using data from Kain 1977 (recovery in clearings). Data are split by age, so here I'm making some assumptions to approximate age into the height-based stages used in the model. Recruits are defined as 0-1 year olds, subcanopy as 1-2 year olds, and canopy as 3+, all limits inclusive. Thus, the boundary ages are used for both stages. We integrate under the curve to estimate the maximum annual growth in open canopy.
```{r extract_growthStipeLength}
recruits <- data.ls$day_growthStipe %>% filter(ageGroup < 2) %>%
  mutate(dailyGrowth=growthStipe/7, stage="recruits", date=as_date(day))
subcanopy <- data.ls$day_growthStipe %>% filter(ageGroup > 0 & ageGroup < 3) %>%
  mutate(dailyGrowth=growthStipe/7, stage="subcanopy", date=as_date(day))
canopy <- data.ls$day_growthStipe %>% filter(ageGroup > 2) %>%
  mutate(dailyGrowth=growthStipe/7, stage="canopy", date=as_date(day))
# recruits.hm <- haRmonics(y=recruits$dailyGrowth,
#                          ts=recruits$day,
#                          method="hants",
#                          low=-20, high=20, fitErrorTol=0.5, degreeOverDeter=1,
#                          lenBasePeriod=365, numFreq=1, delta=0.1)
# subcanopy.hm <- haRmonics(y=subcanopy$dailyGrowth,
#                           ts=subcanopy$day,
#                           method="hants",
#                           low=-20, high=20, fitErrorTol=0.5, degreeOverDeter=1,
#                           lenBasePeriod=365, numFreq=1, delta=0.1)
# canopy.hm <- haRmonics(y=canopy$dailyGrowth,
#                        ts=canopy$day,
#                        method="hants",
#                        low=-20, high=20, fitErrorTol=0.5, degreeOverDeter=1,
#                        lenBasePeriod=365, numFreq=1, delta=0.1)
# 
# 
# hm.1 <- list(a=recruits.hm$a.coef, b=recruits.hm$b.coef, 
#              fit=recruits.hm$fitted, 
#              phase=recruits.hm$phase, amp=recruits.hm$amplitude)
# hm.2 <- list(a=subcanopy.hm$a.coef, b=subcanopy.hm$b.coef, 
#              fit=subcanopy.hm$fitted, 
#              phase=subcanopy.hm$phase, amp=subcanopy.hm$amplitude)
# hm.3 <- list(a=canopy.hm$a.coef, b=canopy.hm$b.coef, 
#              fit=canopy.hm$fitted, 
#              phase=canopy.hm$phase, amp=canopy.hm$amplitude)

day_seq <- seq(ymd("1970-01-01"), ymd("1970-06-30"), by="day")
y <- (yday(day_seq)-1)/c(364,365)[leap_year(day_seq)+1]
# pred.1 <- mean(hm.1$fit) + hm.1$a * cos(2*pi*y) + hm.1$b * sin(2*pi*y)
# pred.2 <- mean(hm.2$fit) + hm.2$a * cos(2*pi*y) + hm.2$b * sin(2*pi*y)
# pred.3 <- mean(hm.3$fit) + hm.3$a * cos(2*pi*y) + hm.3$b * sin(2*pi*y)
# 
# cat("Maximum expected annual growth in stipe length (mm) harmonic model:\n", 
#     round(c(sum(pred.1, na.rm=T), sum(pred.2, na.rm=T), sum(pred.3, na.rm=T))))

pred.1 <- predict(loess(dailyGrowth ~ day, data=recruits), 
        data.frame(day=yday(day_seq)), se=T)
pred.2 <- predict(loess(dailyGrowth ~ day, data=subcanopy), 
        data.frame(day=yday(day_seq)), se=T)
pred.3 <- predict(loess(dailyGrowth ~ day, data=canopy), 
        data.frame(day=yday(day_seq)), se=T)
cat("Maximum expected annual growth in stipe length (mm) loess model:\n", 
    round(sum(pred.1$fit, na.rm=T)), "+-", round(sum(pred.1$se.fit, na.rm=T)), "\n", 
    round(sum(pred.2$fit, na.rm=T)), "+-", round(sum(pred.2$se.fit, na.rm=T)), "\n", 
    round(sum(pred.3$fit, na.rm=T)), "+-", round(sum(pred.3$se.fit, na.rm=T)))


tibble(date=day_seq, recruits=pred.1$fit, subcanopy=pred.2$fit, canopy=pred.3$fit) %>%
  pivot_longer(2:4, names_to="stage", values_to="dailyGrowth") %>%
  mutate(stage=factor(stage, levels=c("canopy", "subcanopy", "recruits"))) %>%
  ggplot(aes(date, dailyGrowth, colour=stage)) + 
  geom_line(size=1) +
  geom_jitter(data=recruits, shape=1) + 
  geom_jitter(data=subcanopy, shape=1) +
  geom_jitter(data=canopy, shape=1) +
  scale_colour_brewer(type="qual", palette=2) +
  scale_x_date(date_labels="%b") +
  labs(title="Stipe growth rate", x="", y="Daily stipe growth (mm)")
```


Frond area growth is much more clearly defined by the seasons, and a simple harmonic model does not qualitatively match the observed pattern. Using the same age boundaries as for stipe growth rate, we approximate the temporal pattern for each stage using a loess smoother and again integrate under the curve. In contrast to stipe growth, we see the greatest growth rates in frond area in the larger stages, with peak growth rates about twice as large in canopy vs. subcanopy plants.
```{r extract_growthFrondArea, warning=F}
frondAreaGrowth <- data.ls$day_areaFrond %>%
  filter(location=="Isle of Man") %>%
  group_by(age) %>%
  mutate(deltaArea=areaFrond-lag(areaFrond),
         deltaDay=day-lag(day),
         rate=deltaArea/deltaDay,
         midptDay=day+deltaDay/2) %>%
  mutate(dateMeasured=lubridate::as_date(round(midptDay))) %>%
  filter(!is.na(rate))

recruits <- frondAreaGrowth %>% filter(age < 2) %>%
  mutate(dailyGrowth=rate, stage="recruits", date=as_date(day))
subcanopy <- frondAreaGrowth %>% filter(age > 0 & age < 3) %>%
  mutate(dailyGrowth=rate, stage="subcanopy", date=as_date(day))
canopy <- frondAreaGrowth %>% filter(age > 2) %>%
  mutate(dailyGrowth=rate, stage="canopy", date=as_date(day))

day_seq <- seq(ymd("1970-01-01"), ymd("1970-06-30"), by="day")
pred.1 <- predict(loess(dailyGrowth ~ day, data=recruits), 
        data.frame(day=yday(day_seq)), se=T)
pred.2 <- predict(loess(dailyGrowth ~ day, data=subcanopy), 
        data.frame(day=yday(day_seq)), se=T)
pred.3 <- predict(loess(dailyGrowth ~ day, data=canopy), 
        data.frame(day=yday(day_seq)), se=T)

cat("Maximum expected annual growth in frond area (cm^2):\n",  
    round(sum(pred.1$fit, na.rm=T)), "+-", round(sum(pred.1$se.fit, na.rm=T)), "\n", 
    round(sum(pred.2$fit, na.rm=T)), "+-", round(sum(pred.2$se.fit, na.rm=T)), "\n", 
    round(sum(pred.3$fit, na.rm=T)), "+-", round(sum(pred.3$se.fit, na.rm=T)))

tibble(date=day_seq, recruits=pred.1, subcanopy=pred.2, canopy=pred.3) %>%
  pivot_longer(2:4, names_to="stage", values_to="dailyGrowth") %>%
  mutate(stage=factor(stage, levels=c("canopy", "subcanopy", "recruits"))) %>%
  ggplot(aes(date, dailyGrowth, colour=stage)) + 
  geom_line(size=1) +
  geom_jitter(data=recruits, shape=1) + 
  geom_jitter(data=subcanopy, shape=1) +
  geom_jitter(data=canopy, shape=1) +
  scale_colour_brewer(type="qual", palette=2) +
  scale_x_date(date_labels="%b") +
  labs(title="Frond area growth rate", x="", y="Daily frond area growth (cm2)")
```



## Maximum height
In Pessarodona (2018), maximum stipe length is contended to be related to temperature. Within the UK, it seems that surface PAR is actually a better predictor (data_demography.Rmd/Height), but it might be best to defer to expertise and stick with temperature. 
```{r stipeMaxHeight, message=F}
if(rerun_modelFits) {
  if(lmType=="brms") {
    sst_maxStipeLen <- data.ls$depth_maxStipeLen %>%
      brm(maxStipeLen ~ sstDay_mn, data=.)
    saveRDS(sst_maxStipeLen, "temp\\brms_sst_maxStipeLen.rds")
  } else {
    sst_maxStipeLen <- data.ls$depth_maxStipeLen %>%
      lm(maxStipeLen ~ sstDay_mn, data=.)
    saveRDS(sst_maxStipeLen, "temp\\lm_sst_maxStipeLen.rds")
  }
} else {
  sst_maxStipeLen <- readRDS(paste0("temp\\", lmType, "_sst_maxStipeLen.rds"))
}
```



## Carrying capacity

There are two options for defining carrying capacity: Density of individuals, or Frond Area Index. The number of individuals relates more to space limitations, while FAI directly relates to density dependent light limitation. Both variables show semi-log linear relationships with depth, and the effect of depth on density is more pronounced in the canopy compared to the subcanopy. 
```{r extract_K, message=F, echo=F}
# Option 1: FAI -- depth dependent
depth_FAI.linlin <- lm(FAI ~ PAR_atDepth, data=data.ls$depth_FAI)
depth_FAI.linlog <- lm(log(FAI) ~ PAR_atDepth, data=data.ls$depth_FAI)
depth_FAI.loglin <- lm(FAI ~ log(PAR_atDepth), data=data.ls$depth_FAI)
depth_FAI.loglog <- lm(log(FAI) ~ log(PAR_atDepth), data=data.ls$depth_FAI)
MuMIn::AICc(depth_FAI.linlin, depth_FAI.loglin, 
            depth_FAI.linlog, depth_FAI.loglog) %>%
  arrange(AICc)

if(rerun_modelFits) {
  if(lmType=="brms") {
    PAR_atDepth_FAI <- data.ls$depth_FAI %>%
      mutate(logFAI=log(FAI),
             logPAR=log(PAR_atDepth)) %>%
      brm(logFAI ~ logPAR, prior=prior(normal(0,5)), data=.)
    saveRDS(PAR_atDepth_FAI, "temp\\brms_PARdepth_FAI_K.rds")
  } else {
    PAR_atDepth_FAI <- data.ls$depth_FAI %>%
      mutate(logFAI=log(FAI),
             logPAR=log(PAR_atDepth)) %>%
      lm(logFAI ~ logPAR, data=.)
    saveRDS(PAR_atDepth_FAI, "temp\\lm_PARdepth_FAI_K.rds")
  }
} else {
  PAR_atDepth_FAI <- readRDS(paste0("temp\\", lmType, "_PARdepth_FAI_K.rds"))
}

data.ls$depth_FAI %>%
  ggplot(aes(log(PAR_atDepth), log(FAI))) + stat_smooth(method="lm") + geom_point() +
  labs(title="FAI ~ PAR_atDepth", x="log(PAR)", y="log(FAI)")


# Option 2: Abundance -- depth dependent
depth_density_stages <- data.ls$lengthStipe_NperSqM %>%
  left_join(., data.ls$lengthStipe_NperSqM %>% 
              group_by(PAR_atDepth) %>% 
              summarise(stipeMin=min(lengthStipe), stipeMax=max(lengthStipe),
                        top33=(stipeMax-stipeMin)*2/3 + stipeMin), 
            by="PAR_atDepth") %>%
  mutate(stage=c("canopy", "subcanopy")[1 + (lengthStipe < top33)]) %>%
  group_by(PAR_atDepth, stage) %>%
  summarise(NperSqM=sum(NperSqM))
depth_density.linlin <- lm(NperSqM ~ PAR_atDepth * stage, data=depth_density_stages)
depth_density.linlog <- lm(log(NperSqM) ~ PAR_atDepth * stage, data=depth_density_stages)
depth_density.loglin <- lm(NperSqM ~ log(PAR_atDepth) * stage, data=depth_density_stages)
depth_density.loglog <- lm(log(NperSqM) ~ log(PAR_atDepth) * stage, data=depth_density_stages)
MuMIn::AICc(depth_density.linlin, depth_density.linlog, 
            depth_density.loglin, depth_density.loglog) %>% 
  arrange(AICc)

if(rerun_modelFits) {
  if(lmType=="brms") {
    depth_N <- depth_density_stages %>%
      mutate(logN=log(NperSqM)) %>%
      brm(logN ~ PAR_atDepth*stage, prior=prior(normal(0,5)), data=.)
    saveRDS(depth_N, "temp\\brms_PARdepth_N_K.rds") 
  } else {
    depth_N <- depth_density_stages %>%
      mutate(logN=log(NperSqM)) %>%
      lm(logN ~ PAR_atDepth*stage, prior=prior(normal(0,5)), data=.)
    saveRDS(depth_N, "temp\\lm_PARdepth_N_K.rds")
  }
} else {
  depth_N <- readRDS(paste0("temp\\", lmType, "_PARdepth_N_K.rds"))
}

depth_density_stages %>%
  mutate(stage=factor(stage, levels=c("canopy", "subcanopy", "recruits"))) %>%
  ggplot(aes(PAR_atDepth, NperSqM, colour=stage)) + 
  geom_point() + stat_smooth(method="lm") + 
  scale_colour_brewer(type="qual", palette=2) + scale_y_log10() +
  labs(title="N ~ PAR_atDepth", x="PAR_atDepth (m)", y="N/m2")
```



## Survival

Pedersen 2012 built a similar stage-based model of L. hyperborea in Norway with three different levels of exposure, and provide all of the parameters as individuals/m^2 at an annual timestep. The sites are quite a bit further north, so I'm not sure how well this translates to Scotland, much less the whole UK.
```{r extract_survival}
library(fitdistrplus); library(truncnorm)
surv.df <- expand_grid(stage=factor(c("recruits", "subcanopy", "canopy"),
                                    levels=c("recruits", "subcanopy", "canopy")),
                       exposure_og=c("low", "med", "high")) %>%
  mutate(exposure=case_when(exposure_og=="low" ~ "low",
                            exposure_og!="low" ~ "high")) %>%
  mutate(N_mn=c(438, 476, 1854, 23.2, 28.6, 66.4, 8.9, 7.3, 12.3),
         N_sd=c(315, 55, 1282, 9, 6, 19, 2.7, 2.1, 0.2),
         dead_mn=c(423, 457, 1804, 10.9, 15.4, 44.9, 4.6, 4.0, 5.0),
         dead_sd=c(308, 52, 1263, 8.1, 4.6, 18.9, 0.7, 1.1, 0.1)) %>%
  rowwise() %>%
  # mutate(s_sim=list(1-rnorm(1e4, dead_mn, dead_sd)/rnorm(1e4, N_mn, N_sd))) %>%
  mutate(N_sim=list(rtruncnorm(1e5, 0, Inf, N_mn, N_sd))) %>%
  unnest(N_sim) %>%
  mutate(dead_sim=rtruncnorm(n(), 0, Inf, dead_mn, dead_sd)) %>%
  mutate(s_sim=1-dead_sim/N_sim)
surv.df$s_sim[surv.df$s_sim >= 1] <- NA
surv.df$s_sim[surv.df$s_sim > 0.5 & surv.df$stage=="recruits"] <- NA
surv.df$s_sim[surv.df$s_sim <= 0 & surv.df$stage=="recruits"] <- 1e-50
surv.df$s_sim[surv.df$s_sim <= 0] <- NA
surv.df <- surv.df %>% filter(!is.na(s_sim)) %>%
  group_by(stage, exposure) %>%
  summarise(shp1=fitdist(s_sim, "beta")$estimate[1],
            shp2=fitdist(s_sim, "beta")$estimate[2]) %>%
  mutate(mn=shp1/(shp1+shp2),
         prec=shp1+shp2) %>%
  arrange(stage, desc(exposure))
par(mfrow=c(3,2))
for(i in 1:nrow(surv.df)) {
  curve(dbeta(x, surv.df$shp1[i], surv.df$shp2[i]), from=0, to=1, 
        main=paste(surv.df$stage[i], surv.df$exposure[i]), ylab="density", xlab="s")
}


write_csv(surv.df, glue("data{sep}par_survival.csv"))


```



## Breakage

Johnston 1977: "40-50% [of gross carbon input] is lost by distal decay" for *L. saccharina*, mostly in the fall. Pessarrodona et al 2019 found something quite different for two species of *Laminaria*, with high loss in *L. hyperborea* only in March and April. All data come from SW England. The timing of accumulation matches Kain above, with a pulse of growth in the spring, peaking March through June. In the absence of other information, it seems that winter frond loss may not be so important in *L. hyperborea*...

Pessarrodona 2019 gives per-plant estimates of dry weight laminar loss (g/day) for each month. I'm not sure about the best way to apply this in the model (i.e., how to get to proportion of frond area lost) without making probably bad assumptions about total frond weight and relying on allometry.
```{r extract_loss, message=F}
pessarrodona.f <- "..\\data\\Pessarrodona2019\\Biomass accumulation and loss.xlsx"
data.ls$month_biomass <- bind_rows(
  readxl::read_xlsx(pessarrodona.f, 1) %>% mutate(type="accumulation"),
  readxl::read_xlsx(pessarrodona.f, 2) %>% mutate(type="loss")
  ) %>%
  mutate(startDate=as_date(paste0("2017-", Month, "-01")),
         chgInMonth=biomassChg*days_in_month(startDate))

data.ls$month_biomass %>%
  ggplot(aes(startDate, chgInMonth, colour=Location)) + 
  geom_jitter(width=5) + stat_smooth(se=F) + 
  facet_grid(Species~type) +
  labs(x="", y="Biomass change (g/month)")

# 'Sample' column is meaningless, so can't compare within individuals
data.ls$month_biomass %>% 
  ggplot(aes(Sample, chgInMonth, colour=type)) + geom_point() +
  facet_wrap(~Species)

# This subtracts the previous year's frond lost in May cast
data.ls$month_biomass %>%
  filter(Species=="L. hyp") %>%
  mutate(MonthAbb=factor(Month, levels=month.name, labels=month.abb),
         Month=factor(Month, levels=month.name),
         season=if_else(MonthAbb %in% month.abb[1:6], "growing", "non-growing")) %>%
  group_by(type, season, Month) %>%
  summarise(mnChg=mean(chgInMonth)) %>%
  group_by(type, season) %>%
  summarise(chgInMonth=sum(mnChg)) %>%
  group_by(season) %>%
  pivot_wider(names_from="type", values_from="chgInMonth") %>%
  mutate(diff=accumulation-loss) %>%
  ggplot(aes(season, diff, fill=diff<0)) + 
  geom_hline(yintercept=0) + 
  geom_bar(stat="identity", colour="grey30") +
  scale_fill_manual(values=c("blue3", "red3")) +
  theme(legend.position="none") +
  labs(x="Season", y="Expected frond biomass change (g DW)")


# Instead, the frond at the end of June = total accumulation - background erosion

# 1. Assume non - May Cast months = chronic erosion
erosion_monthly <- data.ls$month_biomass %>% 
  filter(Species=="L. hyp") %>%
  filter(type=="loss" & Month %in% month.name[-(3:4)]) %>%
  group_by(Month) %>%
  summarise(mnMonthlyLoss=mean(chgInMonth)) %>%
  ungroup #%>%
  #summarise(sdMonthlyLoss=sd(mnMonthlyLoss), mnMonthlyLoss=mean(mnMonthlyLoss))
# 2. Calculate net growth during growing season
netTotalGrowth <- data.ls$month_biomass %>% 
  filter(Species=="L. hyp") %>%
  filter(type=="accumulation" & Month %in% month.name[1:6]) %>%
  group_by(Month) %>%
  summarise(mnMonthlyGrowth=mean(chgInMonth)) %>%
  ungroup %>%
  mutate(netMonthlyGrowth=mnMonthlyGrowth-mean(erosion_monthly$mnMonthlyLoss)) %>%
  summarise(netTotalGrowth=sum(netMonthlyGrowth))

# 3. Calculate % loss during non-growing season
mean(erosion_monthly$mnMonthlyLoss/(netTotalGrowth$netTotalGrowth/6))

# 3a. Calculate a distribution by bootstrapping
library(fitdistrplus)
loss.boot <- map_dbl(1:1e5, 
                     ~sample(erosion_monthly$mnMonthlyLoss, 1, T)/
                       (netTotalGrowth$netTotalGrowth/6))
loss.shpPar <- fitdist(loss.boot, "beta")$estimate
loss.mn_prec <- c(loss.shpPar[1]/sum(loss.shpPar), sum(loss.shpPar))
loss.df <- tibble(stage=NA, exposure=NA, 
                  shp1=loss.shpPar[1], shp2=loss.shpPar[2],
                  mn=loss.mn_prec[1], prec=loss.mn_prec[2])
write_csv(loss.df, glue("data{sep}par_erosion.csv"))


```



## Fecundity

The Pedersen 2012 model included stages for recruits, subcanopy, and canopy, and report the number of annual recruits. In some cases, the values are extremely high. My concerns about geographic differences apply here as well. 
```{r extract_recruitment}
fecund.df <- data.ls$stageFrom_stageTo %>% 
  filter(stageFrom=="canopy" & stageTo=="recruits") %>%
  mutate(exposure=as.numeric(factor(exposure, levels=c("low", "medium", "high"))))
fecund.df



library(fitdistrplus); library(truncnorm)
fecund.df <-tibble(stage=NA, exposure_og=c("low", "med", "high")) %>%
  mutate(exposure=case_when(exposure_og=="low" ~ "low",
                            exposure_og!="low" ~ "high")) %>%
  mutate(N_mn=c(438, 476, 1854),
         N_sd=c(315, 55, 1282)) %>%
  rowwise() %>%
  mutate(z_sim=list(rtruncnorm(1e4, 0, Inf, N_mn, N_sd))) %>%
  unnest(z_sim) %>%
  group_by(stage, exposure) %>%
  summarise(z_mn=mean(z_sim),
            z_sd=sd(z_sim)) %>%
  arrange(desc(exposure))
write_csv(fecund.df, glue("data{sep}par_recruitment.csv"))


```










# Set model parameters

```{r setParams}
depth_i <- 5
sites_pool <- site.sf %>% filter(!is.na(KD_mn)) %>% st_drop_geometry()
env_i <- sites_pool %>% sample_n(1)
pars <- setParameters(
  prFullHarvest=0.7, freqHarvest=5, tmax=50, harvestTarget="stipe",
  survRate=filter(surv.df, exposure==env_i$fetchCat)$survRate^(1/2),
  settlementRateBg=filter(fecund.df, exposure==env_i$fetchCat)$rate,
  extraPars=list(
    depth=depth_i,
    env=env_i,
    lenStipe_wtStipe=lenStipe_wtStipe,
    wtStipe_wtFrond=wtStipe_wtFrond.kappa,
    wtFrond_areaFrond=wtFrond_areaFrond.PAR_atDepth,
    areaFrond_wtFrond=areaFrond_wtFrond.PAR_atDepth,
    depth_N=depth_N,
    depth_FAI=PAR_atDepth_FAI)
)
 

```




# Simulate population
```{r simulate_single}
out <- simulatePopulation_2Seasons(pars, lmType=lmType)

out.df <- tibble(year=rep(1:pars$tmax, 3),
                 month=rep(c(1,6,7), each=pars$tmax),
                 date=ymd(paste0(2000+year, "-", month, "-01")),
                 FAI=c(out$FAI[3,,]),
                 N.recruits=c(out$N[1,,]),
                 N.subcanopy=c(out$N[2,,]),
                 N.canopy=c(out$N[3,,])) %>%
  pivot_longer(contains("N."), names_to="stage", values_to="N") %>%
  mutate(stage=factor(str_sub(stage, 3, -1), 
                      levels=c("canopy", "subcanopy", "recruits")))

ggplot(out.df, aes(date, N, colour=stage)) + geom_line(size=1) +
  scale_colour_brewer(type="qual", palette=2) + scale_y_log10()
ggplot(out.df, aes(date, N, colour=stage, linetype=factor(month))) + 
  geom_line(size=1) + geom_hline(yintercept=out$K_N) +
  scale_colour_brewer(type="qual", palette=2) + scale_y_log10()

out.df %>% filter(stage=="canopy") %>%
  ggplot(aes(date, FAI, colour=factor(month))) + 
  geom_line() + geom_point(shape=1) +
  geom_hline(yintercept=out$K_FAI) + ylim(0, NA)

matplot(out$kappa[,,1], type="l", lty=1, ylim=c(0, 1), ylab="kappa_FAI")
legend("topleft", c("Jan","pre-harvest","post-harvest"), col=1:3, lty=1)
matplot(out$kappa[,,2], type="l", lty=1, ylim=c(0, 1), ylab="kappa_N")
legend("topleft", c("Jan","pre-harvest","post-harvest"), col=1:3, lty=1)

plot(out$harvest/1e3, type="b", xlab="Year", 
     ylab=paste0("Harvest (", pars$harvestTarget, " kg/m2)"))

plot(cumsum(out$harvest/1e3), type="b", xlab="Year", 
     ylab=paste0("Cumulative harvest (", pars$harvestTarget, " kg/m2)"))
```


```{r simulate_iterations, eval=FALSE, include=FALSE}
library(furrr)
plan(multisession)
out <- future_map(1:12, ~simulatePopulation_2Seasons(pars, lmType=lmType), 
                  .options=furrr_options(seed=T))
out.df <- imap_dfr(out, 
                  ~tibble(sim=.y, 
                          year=rep(1:pars$tmax, 3),
                          month=rep(c(1,6,7), each=pars$tmax),
                          date=ymd(paste0(year, "-", month, "-01")),
                          K_N=.x$K_N,
                          K_FAI=.x$K_FAI,
                          FAI=c(.x$FAI[3,,]),
                          N.recruits=c(.x$N[1,,]),
                          N.subcanopy=c(.x$N[2,,]),
                          N.canopy=c(.x$N[3,,])) %>%
                    pivot_longer(contains("N."), names_to="stage", values_to="N") %>%
                    mutate(stage=factor(str_sub(stage, 3, -1), 
                                        levels=c("canopy", "subcanopy", "recruits"))))
out.df %>%
  ggplot(aes(date, N, colour=stage, group=paste0(stage, sim))) + 
  geom_line(alpha=0.1, size=1) +
  scale_colour_brewer(type="qual", palette=2) + scale_y_log10()
out.df %>% filter(stage=="canopy") %>%
  ggplot(aes(date, N, colour=stage, group=paste0(stage, sim))) + 
  geom_line(alpha=0.1, size=1) +
  scale_colour_brewer(type="qual", palette=2) 
out.df %>% filter(month==6) %>%
  ggplot(aes(date, N, colour=stage, group=paste0(stage, sim))) + 
  geom_hline(aes(yintercept=K_N), alpha=0.2) +
  geom_line(alpha=0.1, size=1) +
  scale_colour_brewer(type="qual", palette=2) + scale_y_log10()

out.df %>% filter(stage=="canopy") %>%
  ggplot(aes(date, FAI, group=sim)) + 
  geom_hline(aes(yintercept=K_FAI), alpha=0.2) +
  geom_line(alpha=0.25, size=1) + ylim(0, NA) + facet_grid(.~month)

out.df %>% filter(stage=="canopy") %>%
  group_by(date, month) %>% 
  summarise(FAI_mn=mean(FAI), 
            FAI_q10=quantile(FAI, 0.1),
            FAI_q25=quantile(FAI, 0.25),
            FAI_q75=quantile(FAI, 0.75),
            FAI_q90=quantile(FAI, 0.9),
            K_FAI_mn=mean(K_FAI),
            K_FAI_q10=quantile(K_FAI, 0.1),
            K_FAI_q90=quantile(K_FAI, 0.9)) %>%
  ggplot(aes(date, FAI_mn, ymin=FAI_q10, ymax=FAI_q90)) +
  geom_ribbon(alpha=0.5, colour=NA, fill="grey") +
  geom_ribbon(aes(ymin=FAI_q25, ymax=FAI_q75), 
              alpha=0.75, colour=NA, fill="grey") +
  geom_line(size=1) + ylim(0, NA) + facet_grid(.~month)

imap_dfr(out, 
         ~tibble(sim=.y, 
                 date=ymd(paste0(1:pars$tmax, "-06-01")),
                 harvest=.x$harvest/1e3)) %>%
  ggplot(aes(date, harvest, group=sim)) + 
  geom_point(alpha=0.2, size=1) + ylim(0,NA)
  
imap_dfr(out, 
         ~tibble(sim=.y, 
                 date=ymd(paste0(1:pars$tmax, "-06-01")),
                 harvest=.x$harvest/1e3)) %>%
  group_by(sim) %>%
  mutate(harvestCumulative=cumsum(harvest)) %>%
  ggplot(aes(date, harvestCumulative, group=sim)) + 
  geom_line(alpha=0.2, size=1) + ylim(0,NA)

imap_dfr(out, 
         ~tibble(sim=.y, 
                 date=ymd(paste0(1:pars$tmax, "-06-01")),
                 harvest=.x$harvest/1e3)) %>%
  group_by(sim) %>%
  mutate(harvest=cumsum(harvest)) %>%
  group_by(date) %>% 
  summarise(harvest_mn=mean(harvest), 
            harvest_q10=quantile(harvest, 0.1),
            harvest_q25=quantile(harvest, 0.25),
            harvest_q75=quantile(harvest, 0.75),
            harvest_q90=quantile(harvest, 0.9)) %>%
  ggplot(aes(date, harvest_mn, ymin=harvest_q10, ymax=harvest_q90)) + 
  geom_linerange(colour="grey", size=1) +
  geom_linerange(aes(ymin=harvest_q25, ymax=harvest_q75), 
                 size=2, colour="grey") +
  geom_point() + ylim(0, NA) +
  labs(y="Cumulative harvest")

imap_dfr(out, 
         ~tibble(sim=.y, 
                 date=ymd(paste0(1:pars$tmax, "-06-01")),
                 harvest=.x$harvest/1e3)) %>%
  group_by(date) %>% 
  summarise(harvest_mn=mean(harvest), 
            harvest_q10=quantile(harvest, 0.1),
            harvest_q25=quantile(harvest, 0.25),
            harvest_q75=quantile(harvest, 0.75),
            harvest_q90=quantile(harvest, 0.9)) %>%
  ggplot(aes(date, harvest_mn, ymin=harvest_q10, ymax=harvest_q90)) + 
  geom_linerange(colour="grey", size=1) +
  geom_linerange(aes(ymin=harvest_q25, ymax=harvest_q75), 
                 size=2, colour="grey") +
  geom_point() + ylim(0, NA)
```






